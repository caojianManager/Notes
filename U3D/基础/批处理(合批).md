### 1.什么是批处理？

批处理希望通过对物体网格的重组来获得更高的绘制效率，试想以下如果将多个物体合并为一个物体，那么在绘制的时候只需要绘制一次就够了，因此从这个角度上来讲，这样做可以降低DrawCall.

Unity3D中 进行批处理的一个前提是相同材质的物体可以被合并，如果这些物体使用不同的材质，那么当我们把这些材质对应的纹打成“图集”以后可以对其进行合并，并且在合并的时候应该是用Renderer.sharedMaterial而非Renderer.material以保证材质是可以共享的。

### 2.Unity中批处理的两种方式

#### 静态批处理

>通过将不会移动的静态物体合并到更大的mesh中，以提升渲染速度。

静态批处理因为不需要在CPU中进行顶点转换，所以要比动态批处理快的多，但是会占用更多内存。如果多个物体共享同一个材质，使用静态批处理时，会为每个几何体生成一份拷贝，不管是在编辑器，还是运行时。所以避免在内存紧张的环境下，就需要损失一定的渲染性能来避免静态批处理带来的内存开销。

静态批处理比较简单，只需要将场景中不会动的静态物品设置Batching Static,剩下的交给引擎了。

静态批处理的原理:是将物体转换到世界空间，并为他们建立一个共享顶点和索引缓存。在Player  Setting中勾选了Opeimized Mesh Data以后，Unity在构建缓存时，会移除哪些在所有shader变体中都没有被用到的顶点的elements(官方文档里是这么说的，不知道该翻译成什么，顶点的属性？)。Unity通过一些特殊的关键字检查来实现这个操作，比如如果没有包含LIGHTMAP_ON，该批处理的顶点输入中就会删除lightmap UVs。

静态批处理，并不是所有的模型都合并到同一个Mesh里，合并的时候仍然受限于mesh的顶点数要求，在大多数平台上，批处理限制是64k个顶点和64k个索引（OpenGLES上48k个索引，macOS上32k个索引）。如果几个模型的顶点总数超过了这个限制，就会被拆分成多个draw call，但是这样的拆分，并不会造成setpass call的变化，因为渲染状态没有变化，所以这些被分开的渲染批次仍然执行的很快。


#### 动态批处理

>对足够小的mesh，动态批处理通过将他们的顶点整合到一个批次中进行绘制。

动态批处理需要特殊设置，引擎会在满足条件的时候自动处理，但是动态批处理的条件非常苛刻，任何一点不满足就不能实现批处理。

Unity会自动为你完成动态批处理，只要你的东西符合它的要求，要求如下：

- 对于顶点的要求只有两个：第一单个mesh的顶点数必须小于300，第二：单个mesh**全部顶点的属性总个数**必须小于900**。**至于300，和180，那只是为了解释这两个要求举的例子！换一种说法就是，如果你的顶点输入中有三个属性，那么就可以支持300个顶点，如果输入中有5个属性，那就只能支持180个顶点，因为180*5=900。至于提到的顶点位置，法线切线UV等等，都只是举个例子。
- 如果物体做了镜像，也就是缩放中出现了负值，则不会进行批处理。**至于都为正数的缩放，测试过程中同时观察了SetPass call和Draw call，都可以正常合并。**如果使用较老的版本，建议自行测试。
- 使用了光照贴图的对象，光照贴图的相关参数必须一致。
- 多通道(Multi-pass)的材质，如果两个对象的渲染使用的通道（pass）不一致，也会中断批处理。

动态批处理会在每帧都会在CPU中将模型的顶点转换到世界坐标系，这部分的消耗也要权衡。

还有几点需要注意的：
- 能够批处理的包括：Mesh Renderers,Trail Renderers,Line Renderers,Particle Systems,Sprite Renderers。其他的如Skinned Meshes,Cloth等渲染组件并能批处理。
- 半透明物体在渲染时，使用的是从远到近的顺序，所以批处理对它的支持不如Opaque。
- 手动合并（通过建模软件，或者Mesh.CombineMeshes方法）临近的物体，有时候也是不错的优化方式。