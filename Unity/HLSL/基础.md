# 基础

## 1.将HLSL代码添加到ShaderLab代码中

```hlsl
 Pass {
        // ... 常规通道状态设置 ...
      
        HLSLPROGRAM
        // 此代码片段的编译指令，例如：
        #pragma vertex vert  //声明顶点着色器函数
        #pragma fragment frag   //声明片元着色器函数
      
        // 着色器程序本身
      
        ENDHLSL

        // ... 通道的剩余部分 ...
    }
```

## 二.着色器语义

> 编写HLSL着色器程序时，输入和输出需要通过**语义**来表明其“意图”;

### 顶点着色器输入语义

顶点着色器函数的每一个参数都需要具备语义。这些语义对应单个网格数据元素(eg:位置,法线和uv坐标)。

如下是一个简单的示例，它采用顶点位置和纹理坐标作为输入。

```hlsl
Shader "Unlit/Show UVs"
{
    SubShader
    {
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            struct v2f {
                float2 uv : TEXCOORD0;
                float4 pos : SV_POSITION;
            };

            v2f vert (
                float4 vertex : POSITION, // 顶点位置输入
                float2 uv : TEXCOORD0 // 第一个纹理坐标输入
                )
            {
                v2f o;
                o.pos = UnityObjectToClipPos(vertex);
                o.uv = uv;
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                return fixed4(i.uv, 0, 0);
            }
            ENDCG
        }
    }
}
```

### 片元着色器输出语义

常，片元（像素）着色器会输出颜色，并具有 SV_Target 语义。

```hlsl
fixed4 frag (v2f i) : SV_Target
```

函数 **frag** 的返回类型为 **fixed4**（低精度 RGBA 颜色）。因为它只返回一个值，所以语义 由函数自身指示: SV_Target。

还可以返回带有输出的结构。

```hlsl

struct fragOutput {
    fixed4 color : SV_Target;
};
fragOutput frag (v2f i)
{
    fragOutput o;
    o.color = fixed4(i.uv, 0, 0);
    return o;
}
```

从片元着色器返回结构对于不止返回单个颜色的着色器非常有用。片元着色器输出支持其他语义如下：

**SV_TargetN：多个渲染目标**

SV_Target1、SV_Target2 等等：这些是着色器写入的附加颜色。这在一次渲染到多个渲染目标（称为“多渲染目标”渲染技术，简称 MRT）时使用。SV_Target0 等同于 SV_Target。

**SV_Depth：像素着色器深度输出**

Usually the fragment shader doesn’t override the Z buffer value, and a default value is used from the regular triangle rasterization. However, for some effects it’s useful to output custom Z buffer depth values per pixel.

Note that on many GPUs this turns off some depth buffer optimizations, so don’t override Z buffer value without a good reason. The cost incurred by SV_Depth varies depending on the GPU architecture, but overall it’s fairly similar to the cost of alpha testing (using the built-in clip() function in HLSL). Render shaders that modify depth after all regular opaque shaders (for example, by using the AlphaTest rendering queue.

深度输出值必须为单个 float。