# 问题记录

## C++虚函数和纯虚函数的区别？

>这里需要先了解些概念

+ 定义一个函数为**虚函数**，**不代表函数为不被实现的函数**。
+ 定义他为虚函数是**为了允许用基类的指针来调用子类的这个函数**。
+ 定义一个**函数为纯虚函数，才代表函数没有被实现**。
+ 定义**纯虚函数是为了实现一个接口，起到一个规范的作用**，规范继承这个类的程序员必须实现这个函数。

示例：

```C++
class A
{
public:
    virtual void foo()
    {
        cout<<"A::foo() is called"<<endl;
    }
};
class B:public A
{
public:
    void foo()
    {
        cout<<"B::foo() is called"<<endl;
    }
};
int main(void)
{
    A *a = new B();
    a->foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!
    return 0;
}
```

上面的示例是虚函数的一个典型应用，它虚就虚在所谓"推迟联编"或者"动态联编"上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为"虚"函数。

> 虚函数只能借助于指针或者引用来达到多态的效果。

### c++纯虚函数

**1.定义**：纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:

`virtual void funtion1()=0`

**2.引入原因**:

+ 方便使用多态特性，我们常常需要在基类中定义虚拟函数。
+ 很多情况下，基类本身生成对象是不合情理的.(eg:动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。)

为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。

声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。

**纯虚函数最显著的特征是**：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。

定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。

纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。所以类纯虚函数的声明就是在告诉子类的设计者，"你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它"。